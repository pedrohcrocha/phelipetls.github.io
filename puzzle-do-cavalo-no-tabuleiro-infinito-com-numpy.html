<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>Puzzle do cavalo no tabuleiro infinito com NumPy · Phelipe</title> <meta name="description" content="Introdução"> <link rel="icon" href="https://phelipetls.github.io/assets/favicon.png"> <link rel="apple-touch-icon" href="https://phelipetls.github.io/assets/touch-icon.png"> <link rel="stylesheet" href="https://phelipetls.github.io/assets/core.css"> <link rel="canonical" href="https://phelipetls.github.io/puzzle-do-cavalo-no-tabuleiro-infinito-com-numpy"> <link rel="alternate" type="application/atom+xml" title="Phelipe" href="https://phelipetls.github.io/feed.xml" /> <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css"> <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} }); </script> <script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script> <!-- Global site tag (gtag.js) - Google Analytics --> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-136684675-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-136684675-1'); </script> </head> <body> <aside class="logo"> <a href="https://phelipetls.github.io/"> <img src="https://avatars3.githubusercontent.com/u/39670535?s=460&amp;v=4" class="logo-avatar"> </a> <span class="logo-prompt code">Back to Index</span> </aside> <div id="content"> <article> <div class="center"> <h1 class="title">Puzzle do cavalo no tabuleiro infinito com NumPy</h1> <time class="code">February 18, 2019 | </time> <cats> <a href="/categories/#Python">Python</a>, </cats> <cats> <a href="/categories/#Estat%C3%ADstica">Estatística</a> </cats> </div> <p></p>
<div class="center"><small>Tags: <cats> <a href="/tag/numpy">Numpy</a>, </cats> <cats> <a href="/tag/monte-carlo">Monte carlo</a>, </cats> <cats> <a href="/tag/matplotlib">Matplotlib</a> </cats> </small></div> <div class="divider"></div> <h5 id="introdução">Introdução</h5> <p class="center"><img src="../images/knight.png" alt="Img"></p> <p>Para estrear o blog, escolhi explorar um puzzle probabilístico, que vi no <a href="http://varianceexplained.org/r/knight-chess/">blog do David Robinson</a>, que consiste em estimar a probabilidade de um cavalo voltar à sua posição inicial após ter saltado aleatoriamente 20 vezes num tabuleiro de xadrez infinito (sendo os 8 possíveis saltos igualmente prováveis).</p> <p>Em seu post, David inteligemente escolhe abordar o problema pelo tidyverse, o que o permite simular o experimento de maneira eficiente e numa estrutura que facilita a criação de visualizações do problema com o ggplot2.</p> <p>Porém esse aqui não é um post sobre R. Como estou aprendendo Python, achei que seria interessante tentar fazer a mesma simulação com uma de suas bibliotecas mais famosas, o Numpy, para praticar e ver se ele cumpre o que promete: operações vetorizadas e eficientes.</p> <h6 id="o-que-está-por-trás-da-eficiência-do-numpy">O que está por trás da eficiência do Numpy</h6> <p>O Numpy chega para suprir uma desvantagem que o Python tem por ser uma linguagem de tipagem dinâmica e de script (não-compilada): ele não é tão bom em fazer repetidas operações múltiplas vezes. Precisamente o que garante a ele uma vantagem pelo lado do desenvolvimento de código (uma linguagem solta, fácil de aprender) é o que compromete sua performance.</p> <p>Para ilustrar essa dificuldade, vamos imaginar que queremos somar duas listas de números elemento por elemento. Uma lista em Python comporta qualquer tipo de dado (integer, float, string, ou até outras listas), e ele não tem como saber de antemão que a lista é composta somente de integers, por exemplo. Então, o que ele fará a cada operação é primeiro verificar o tipo de cada elemento para depois descobrir que “soma” ele deve fazer. Porque, por exemplo, somar dois integers é diferente de somar dois strings:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">+</span><span class="mi">2</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">'1'</span><span class="o">+</span><span class="s">'2'</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'12'
</code></pre></div></div> <p>E é esse type-checking uma das razões que acabam retardando muito a operação como um todo, principalmente quando isso vai se acumulando na casa dos milhões. Numa linguagem compilada e em que você precisa declarar o tipo de suas variáveis, isso não seria um problema.</p> <p>O que o Numpy faz é, ao invés de verificar o tipo dos elementos cada vez que a operação for chamada, ele o faz uma vez somente para depois executar a operação a partir dessa informação (para isso serve o atributo ‘dtype’ do ndarray - de n-dimensional array -, a estrutura de dados básica do Numpy). Além disso, as operações rodam no background em código C.</p> <p>O custo disso é que a estrutura básica do Numpy perde a flexibilidade da lista, já que ele comportará um tipo de dado somente. Mas é um custo que estamos dispostos a pagar. Por exemplo:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

<span class="n">a</span><span class="o">.</span><span class="n">dtype</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dtype('int32')
</code></pre></div></div> <p>Se tentarmos incluir um string nesse ndarray, ele será convertido para um integer:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">'12'</span>
<span class="n">a</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([12,  2,  3,  4])
</code></pre></div></div> <p>Mas se tentarmos incluir um número complexo, obtemos um erro:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">+</span><span class="mf">1j</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-6-65561a8fbe75&gt; in &lt;module&gt;
----&gt; 1 a[0] = 2+1j


TypeError: can't convert complex to int
</code></pre></div></div> <p>Esse comportamento é muito similar ao vetor do R.</p> <h6 id="simulando-os-movimentos-do-cavalo">Simulando os movimentos do cavalo</h6> <p>Dito isto, vejamos o que o Numpy pode fazer. Mas antes um esclarecimento - devo todo o thought process no que diz respeito à modelagem ao Robinson, e encorajo a todos lendo que confiram o post dele, se não antes, depois de ler aqui. O único trabalho que tive foi o de escrever o código em Python.</p> <p>A ideia de Robinson para a simulação foi imaginar o tabuleiro como um plano cartesiano, em que o cavalo está no ponto de origem, (0, 0), podendo saltar dali para oito casas possíveis, com igual probabilidade, respeitando sempre as regras do xadrez, como na imagem:</p> <p><img src="https://raw.githubusercontent.com/phelipetls/phelipetls.github.io/master/images/knight_moves.png" alt="Knight"></p> <p>Daí podemos notar que, se o cavalo pular para uma casa de coordenada x, a coordenada y terá que ser igual a 3 - abs(x). Mas devemos tomar o cuidado para assegurar que a coordenada y também possa ser negativa.</p> <p>Com isso em mente, podemos simular um único salto.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># sorteamos um dos números em parênteses para obter o x
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>

<span class="c1"># e calculamos o y pela relação já descrita
</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2 1
</code></pre></div></div> <p>Mas, é claro, não é interessante simular somente um salto. Queremos, na verdade, 20 deles, precisamos de um vetor.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">move_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">move_y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">move_x</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">move_x</span><span class="p">,</span> <span class="n">move_y</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[-2  1 -1  2  1  1  2  2 -1 -2 -2  2 -1  2 -2  2 -1  1  2  1]
[-1  2  2 -1 -2 -2  1 -1  2  1 -1  1  2 -1 -1  1 -2 -2  1  2]
</code></pre></div></div> <p>Ótimo! Foi bastante simples. É legal observar como funciona a sintaxe do Numpy. Por ele ser totalmente voltado para operações vetoriais, podemos fazer operações aritméticas em vetores elemento por elemento sem qualquer for loop, bata subtrair de 3 o valor absoluto do vetor move_x, como se ele fosse um escalar, e está feito!</p> <p>Agora, sabendo disso, se realmente quisermos computar uma probabilidade, de nada adianta termos somente uma amostra com vinte saltos aleatórios do cavalo, precisamos de muitas mais. Vejamos com cem mil vezes mais. Com o Numpy, isso é bem fácil de ser feito.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">move_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span> <span class="o">*</span> <span class="mi">100000</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">100000</span><span class="p">))</span>
<span class="n">move_y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">move_x</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span> <span class="o">*</span> <span class="mi">100000</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">100000</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="n">move_x</span><span class="p">,</span> <span class="n">move_y</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s">'</span><span class="se">\n\n</span><span class="s">'</span><span class="p">)</span> <span class="c1"># sep = '\n\n' serve para espaçar o output do print
</span></code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[ 1 -2  1 ... -1  2  2]
 [ 1  1 -2 ...  2  2 -2]
 [ 1  2 -1 ... -1  1  1]
 ...
 [-1  1  1 ...  2  2 -2]
 [-1  1  2 ...  1 -1  2]
 [-1 -2  1 ...  2 -2  2]]

[[-2  1 -2 ...  2  1  1]
 [ 2 -2 -1 ...  1 -1 -1]
 [ 2 -1 -2 ...  2  2  2]
 ...
 [-2 -2  2 ...  1  1  1]
 [-2  2 -1 ...  2 -2 -1]
 [-2 -1 -2 ...  1 -1 -1]]
</code></pre></div></div> <p>No código acima eu primeiro gerei 2 milhões de saltos em um vetor, e depois o reorganizei como uma matriz 20 x 100.000. Me acostumei a enxergar matrizes como vários vetores-coluna agrupados, então foi assim que fiz, questão de preferência. Dessa forma, cada coluna representa uma tentativa e cada linha um salto.</p> <p>Para o próximo passo, queremos descobrir em que posição o cavalo está na medida em que se move pelo tabuleiro. Podemos fazer isso ao calcular a soma cumulativa das colunas.</p> <p>Para isso, basta utilizarmos o método ‘cumsum’ do ndarray, com o argumento de axis igualado a 0, o que quer dizer que ele vai fazer a soma cumulativa “down the rows”, linhas abaixo (o 0 é porque a linha é o “primeiro” elemento do “shape” de uma matriz bidimensional, (20, 100000)), o que é justamente o que queremos, já que interpretamos cada linha como um salto:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">position_x</span> <span class="o">=</span> <span class="n">move_x</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">position_y</span> <span class="o">=</span> <span class="n">move_y</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">position_x</span><span class="p">,</span> <span class="n">position_y</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s">'</span><span class="se">\n\n</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[ 1 -2  1 ... -1  2  2]
 [ 2 -1 -1 ...  1  4  0]
 [ 3  1 -2 ...  0  5  1]
 ...
 [ 4 -5 -8 ...  4 17  3]
 [ 3 -4 -6 ...  5 16  5]
 [ 2 -6 -5 ...  7 14  7]]

[[ -2   1  -2 ...   2   1   1]
 [  0  -1  -3 ...   3   0   0]
 [  2  -2  -5 ...   5   2   2]
 ...
 [ 12  -7 -12 ...   0   9   1]
 [ 10  -5 -13 ...   2   7   0]
 [  8  -6 -15 ...   3   6  -1]]
</code></pre></div></div> <p>Mas, como o que nos interessa para responder ao problema é somente a última linha (onde ele parou no plano quando deu o último salto), podemos extrair somente ela pedindo a linha de indíce -1 de nossa matriz (no Python, -1 equivale ao último elemento, -2 ao penúltimo etc.).</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">position_x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">position_y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sep</span> <span class="o">=</span> <span class="s">'</span><span class="se">\n\n</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ 2 -6 -5 ...  7 14  7]

[  8  -6 -15 ...   3   6  -1]
</code></pre></div></div> <p>Agora, para de fato termos uma estimativa da probabilidade do cavalo voltar à origem após 20 saltos aleatórios, vamos calcular a frequência relativa desse evento em cem mil tentativas. Podemos fazer isso da seguinte maneira:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="n">position_x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">position_y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0.00648
</code></pre></div></div> <p>Aqui, o que o Numpy fez primeiro foi criar um vetor de booleans, ao comparar os dois vetores elemento por elemento, retornando Verdadeiro somente quando ambos foram iguais a zero, caso em que ele retornou para a origem concluído seu random walk.</p> <p>Calculado esse vetor, o que fiz foi pedir sua média, e isso me dá justamente a frequência relativa do evento de interesse: é a contagem das vezes que o evento aconteceu (a soma dos verdadeiros, lidos como 1 pelo método ‘mean’) sobre o comprimento do vetor.</p> <p>E assim está pronto. Este é um resultado coerente com o obtido por Robinson, o que é confortante. A probabilidade em questão é de aproximadamente 0.6%; ou seja, a cada 1000 tentativas, podemos esperar que, em média, em 6 delas o cavalo voltará à origem após dar 20 saltos aleatórios.</p> <p>Podemos ter um relance da distribuição de probabilidades do problema com um simples histograma, feito com 100 repetições do experimento.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>

<span class="c1"># isso é uma list comprehension
</span><span class="n">knight_probs</span> <span class="o">=</span> <span class="p">[</span><span class="n">knight_infinite_board</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">knight_probs</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
</code></pre></div></div> <p class="center"><img src="https://raw.githubusercontent.com/phelipetls/phelipetls.github.io/master/images/hist.png" alt="Hist"></p> <h5 id="a-eficiência-em-números">A eficiência em números</h5> <p>E, só para coisa não ficar vaga, quão eficiente é o Numpy afinal? Podemos verificar isso facilmente com o magic command do IPython, o %%timeit. Criei uma função que toma como argumento qualquer número de tentativas para testarmos o algoritmo.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">knight_infinite_board</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="n">move_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span> <span class="o">*</span> <span class="n">trials</span><span class="p">)</span>
    <span class="n">move_y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">move_x</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span> <span class="o">*</span> <span class="n">trials</span><span class="p">)</span>

    <span class="n">position_x</span> <span class="o">=</span> <span class="n">move_x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="n">trials</span><span class="p">))</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">position_y</span> <span class="o">=</span> <span class="n">move_y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="n">trials</span><span class="p">))</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">((</span><span class="n">position_x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">position_y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%%</span><span class="n">timeit</span>
<span class="n">knight_infinite_board</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span> <span class="c1"># cem mil tentativas
</span></code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>130 ms ± 4.16 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%%</span><span class="n">timeit</span>
<span class="n">knight_infinite_board</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span> <span class="c1"># 1 milhão!
</span></code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.15 s ± 97.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre></div></div> <p>É extraordinariamente rápido. Mesmo quando se trata de cálculos com uma matriz de 20 x 1 milhão! E meu computador certamente não ajuda. O mesmo feito no base Python seria absurdamente mais lento.</p> <h6 id="conclusões">Conclusões</h6> <p>Acho que com esse simples exercício, pudemos mesmo atestar que o Numpy é uma ferramenta muito útil, garantindo eficiência com uma sintaxe simples e limpa. Há dentro dele ainda muito mais a ser explorado do que o exposto aqui, incluindo as mais diversas distribuições probabílistas com np.random, manipulação de matrizes com np.linalg etc. O numpy é muito usado pelas mais importantes bibliotecas relacionadas a Data Science e Machine Learning, como pandas e scikit-learn, por isso um conhecimento apropriado de suas funcionalidades pode ajudar muito se o objetivo é crescer na área de data science.</p> <p>Pretendo trazer outros posts em que o usarei, mas por ora ficarei por aqui. Espero que tenha sido proveitoso. Toda crítica/sugestão será muito bem-vinda. Até <img class="emoji" title=":smile:" alt=":smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png" height="20" width="20">.</p> </article> <div class="page-navigation code"> <a class="next" href="https://phelipetls.github.io/tres-algoritmos-para-a-sequencia-de-fibonacci" title="NEXT: Três algoritmos para a sequência de Fibonacci">&lt;&lt;</a> <span> · </span> <a class="home" href="https://phelipetls.github.io/" title="Back to Index">Index</a> </div> <div class="center"> <b></b> <style> #share-buttons {display: inline-block; vertical-align: middle; } #share-buttons:after {content: ""; display: block; clear: both;} #share-buttons > div { position: relative; text-align: left; height: 36px; width: 32px; float: left; text-align: center; } #share-buttons > div > svg {height: 16px; fill: #d5d5d5; margin-top: 10px;} #share-buttons > div:hover {cursor: pointer;} #share-buttons > div.facebook:hover > svg {fill: #3B5998;} #share-buttons > div.twitter:hover > svg {fill: #55ACEE;} #share-buttons > div.linkedin:hover > svg {fill: #0077b5;} #share-buttons > div.pinterest:hover > svg {fill: #CB2027;} #share-buttons > div.gplus:hover > svg {fill: #dd4b39;} #share-buttons > div.mail:hover > svg {fill: #7D7D7D;} #share-buttons > div.instagram:hover > svg {fill: #C73B92;} #share-buttons > div.facebook > svg {height: 18px; margin-top: 9px;} #share-buttons > div.twitter > svg {height: 20px; margin-top: 8px;} #share-buttons > div.linkedin > svg {height: 19px; margin-top: 7px;} #share-buttons > div.pinterest > svg {height: 20px; margin-top: 9px;} #share-buttons > div.gplus > svg {height: 17px; margin-top: 9px; position: relative; left: 1px;} #share-buttons > div.mail > svg {height: 14px; margin-top: 11px;} </style> <span style="color: silver;"><br>Compartilhe: </span><div id="share-buttons"> <div class="facebook" title="Share this on Facebook" onclick="window.open('http://www.facebook.com/share.php?u=https://phelipetls.github.io/puzzle-do-cavalo-no-tabuleiro-infinito-com-numpy');"><svg viewbox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759h-306v-759h-255v-296h255v-218q0-186 104-288.5t277-102.5q147 0 228 12z"></path></svg></div> <div class="twitter" title="Share this on Twitter" onclick="window.open('http://twitter.com/home?status=https://phelipetls.github.io/puzzle-do-cavalo-no-tabuleiro-infinito-com-numpy');"><svg viewbox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5t-115.5 248.5-184.5 210.5-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5t-114-159.5q33 5 61 5 43 0 85-11-112-23-185.5-111.5t-73.5-205.5v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5t371.5 99.5q-8-38-8-74 0-134 94.5-228.5t228.5-94.5q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z"></path></svg></div> <div class="linkedin" title="Share this on Linkedin" onclick="window.open('https://www.linkedin.com/shareArticle?mini=true&amp;url=https://phelipetls.github.io/puzzle-do-cavalo-no-tabuleiro-infinito-com-numpy&amp;title=&amp;summary=&amp;source=');"><svg viewbox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M477 625v991h-330v-991h330zm21-306q1 73-50.5 122t-135.5 49h-2q-82 0-132-49t-50-122q0-74 51.5-122.5t134.5-48.5 133 48.5 51 122.5zm1166 729v568h-329v-530q0-105-40.5-164.5t-126.5-59.5q-63 0-105.5 34.5t-63.5 85.5q-11 30-11 81v553h-329q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5 114.5-15.5q171 0 275 113.5t104 332.5z"></path></svg></div> <div class="gplus" title="Share this on Google Plus" onclick="window.open('https://plus.google.com/share?url=https://phelipetls.github.io/puzzle-do-cavalo-no-tabuleiro-infinito-com-numpy');"><svg viewbox="0 0 2304 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1437 913q0 208-87 370.5t-248 254-369 91.5q-149 0-285-58t-234-156-156-234-58-285 58-285 156-234 234-156 285-58q286 0 491 192l-199 191q-117-113-292-113-123 0-227.5 62t-165.5 168.5-61 232.5 61 232.5 165.5 168.5 227.5 62q83 0 152.5-23t114.5-57.5 78.5-78.5 49-83 21.5-74h-416v-252h692q12 63 12 122zm867-122v210h-209v209h-210v-209h-209v-210h209v-209h210v209h209z"></path></svg></div> <div class="mail" title="Share this through Email" onclick="window.open('mailto:?&amp;body=https://phelipetls.github.io/puzzle-do-cavalo-no-tabuleiro-infinito-com-numpy');"><svg viewbox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1792 710v794q0 66-47 113t-113 47h-1472q-66 0-113-47t-47-113v-794q44 49 101 87 362 246 497 345 57 42 92.5 65.5t94.5 48 110 24.5h2q51 0 110-24.5t94.5-48 92.5-65.5q170-123 498-345 57-39 100-87zm0-294q0 79-49 151t-122 123q-376 261-468 325-10 7-42.5 30.5t-54 38-52 32.5-57.5 27-50 9h-2q-23 0-50-9t-57.5-27-52-32.5-54-38-42.5-30.5q-91-64-262-182.5t-205-142.5q-62-42-117-115.5t-55-136.5q0-78 41.5-130t118.5-52h1472q65 0 112.5 47t47.5 113z"></path></svg></div> </div> </div> <div class="disqus_layout"> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://phelipetls.github.io/puzzle-do-cavalo-no-tabuleiro-infinito-com-numpy'; this.page.identifier = '/puzzle-do-cavalo-no-tabuleiro-infinito-com-numpy'; }; (function() { var d = document, s = d.createElement('script'); s.src = '//phelipetls-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript> </div> </div> <div class="footer"> <a href="https://github.com/phelipetls"><i class="fa fa-github"></i></a> <a style="padding-left:10px;" href="https://linkedin.com/in/phelipeteles"><i class="fa fa-linkedin"></i></a> <a style="padding-left:10px;" href="mailto:phelipe_teles@hotmail.com"><i class="fa fa-envelope"></i></a> <p> <span class="block">© 2019 Phelipe Teles</span> <span class="block"><small>&lt;/&gt; Powered by <a href="https://jekyllrb.com/">Jekyll</a> and <a href="https://github.com/heiswayi/the-plain">The Plain theme</a>.</small></span> </p> </div> </body> </html>
