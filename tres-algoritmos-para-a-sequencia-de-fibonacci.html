<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>Três algoritmos para a sequência de Fibonacci · Phelipe</title> <meta name="description" content=""> <link rel="icon" href="https://phelipetls.github.io/assets/favicon.png"> <link rel="apple-touch-icon" href="https://phelipetls.github.io/assets/touch-icon.png"> <link rel="stylesheet" href="https://phelipetls.github.io/assets/core.css"> <link rel="canonical" href="https://phelipetls.github.io/tres-algoritmos-para-a-sequencia-de-fibonacci"> <link rel="alternate" type="application/atom+xml" title="Phelipe" href="https://phelipetls.github.io/feed.xml" /> <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css"> <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} }); </script> <script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script> <!-- Global site tag (gtag.js) - Google Analytics --> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-136684675-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-136684675-1'); </script> </head> <body> <aside class="logo"> <a href="https://phelipetls.github.io/"> <img src="https://avatars3.githubusercontent.com/u/39670535?s=460&v=4" class="logo-avatar"> </a> <span class="logo-prompt code">Back to Index</span> </aside> <div id="content"> <article> <div class="center"> <h1 class="title">Três algoritmos para a sequência de Fibonacci</h1> <time class="code">March 3, 2019 | </time> <cats> <a href="/categories/#Python">Python</a>, </cats> <cats> <a href="/categories/#Álgebra Linear">Álgebra Linear</a> </cats> </div> <p><div class = "center"><small>Tags: <cats> <a href="/tag/numpy">Numpy</a>, </cats> <cats> <a href="/tag/algoritmos">Algoritmos</a> </cats> </small></div></p> <div class="divider"></div> <p><img src="../images/kisspng-fibonacci-number-golden-spiral-golden-ratio-mathem-spiral-5b4a12ee4a0493.6897256215315811663032.png" alt="FibSeq" /></p> <p>A sequência de fibonacci é uma velha conhecida dos que estudam programação. Por isso, esse post não deve soar tão estimulante para pessoas que trabalham com programação há muito tempo, mas prometo que algo ainda pode ser aproveitado. Aqui pretendo mostrar três algoritmos para sequência, e todos eles foram importantes para melhorar meu entendimento de programação.</p> <p>O primeiro deles é o mais usual. O segundo é por recursão. Já o terceiro é o que me motivou a fazer o post, nele faço uso extensivo de álgebra linear, e com isso é possível aprender muito mais a fundo sobre a natureza desses números, por exemplo, o que caracteriza o seu crescimento?</p> <p>O primeiro eu vi pela primeira vez escrito em C++ num curso de informática que fiz. O segundo, num curso de <a href="https://www.youtube.com/watch?v=ytpJdnlu9ug&amp;list=PLUl4u3cNGP63WbdFxL8giv4yhgdMGaZNA">Introdução à Ciência da Computação</a> do MIT OpenCourseWare. E o terceiro na <a href="https://youtu.be/13r9QY6cmjc">aula 22</a> do curso de Linear Algebra do MIT OpenCourseWare, com Gilbert Strang, cujas aulas são masterpieces. O segredo desta maneira está em ver a sequência de Fibonacci como um sistema de equações lineares dinâmico, que evolui no tempo. E para entender melhor como isso funciona, precisamos introduzir o conceito de autovalores/autovetores. Mas antes vejamos os algoritmos mais simples.</p> <h5 id="a-maneira-comum">A maneira comum</h5> <p>Apenas para recordar o que é a sequência de fibonacci: dados os dois primeiros números da sequência (comumente 0 e 1), o próximo número é a soma dos dois que o precedem.</p> <script type="math/tex; mode=display">F_0 = 0, F_1 = 1</script> <script type="math/tex; mode=display">F_n = F_{n-1} + F_{n-2}</script> <p>Com isso em mente, podemos escrever o algoritmo que muitos já devem conhecer.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">std_fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="c1"># tuple assignment
</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">fib</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">fib</span>

    <span class="k">return</span> <span class="n">fib</span>

<span class="p">[</span><span class="n">std_fib</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">)]</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233]
</code></pre></div></div> <p>Acredito que não muito possa ser dito sobre este algoritmo, mas é interessante tentar escrevê-lo de um jeito mais <em>pythonic</em>.</p> <p>Por exemplo, legal pontuar como atribuí os valores às variáveis. O que tá rolando ali é chamado de tuple assignment. No Python, você pode atribuir o conteúdo de uma lista, tuple etc. a variáveis numa única linha. Em outra linguagem talvez precisaríamos de variáveis temporárias para isso.</p> <p>Caso alguém nunca tenha visto esse algoritmo, poso explicar brevemente. Primeiro atribuímos à variável “a” o valor 0, e à “b” o valor 1. Depois, no loop, calculamos o número de fibonacci, que é a soma desses dois. O primeiro, então, é 1. Em seguida, o que fazemos é atribuir à “a” o valor de “b” e à “b” o valor do número de fibonacci, de forma que no próximo loop, a soma será 1 + 1, e no próximo 1 + 2, 2 + 3 etc.</p> <p>Para comparação, vamos testar sua performance em termos de eficiência.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">timeit</span> <span class="n">std_fib</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2.46 ms ± 96.5 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre></div></div> <h5 id="por-recursão">Por recursão</h5> <p>Como não sou estudante de ciência da computação, esse eu conheci recentemente até e achei maravilhoso. Ele tem a vantagem de ser bem legível, limpo.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">rec_fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rec_fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">rec_fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

<span class="p">[</span><span class="n">rec_fib</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">13</span><span class="p">)]</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
</code></pre></div></div> <p>E funciona da seguinte forma: Primeiro, temos um caso base (<em>base case</em>), em que o valor é conhecido.</p> <p>Neste caso, definimos que os números 0 e 1 da sequência de fibonacci são, respectivamente, 0 e 1. Para todos os outros, calculamos de forma recursiva. Por exemplo, $F_3 = F_2 + F_1 = F_1 + F_0 + F_1 = 1 + 0 + 1 = 2$</p> <p>E é uma boa maneira de introduzir o conceito de recursão na computação. Agora vejamos quão eficiente ele é.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">timeit</span> <span class="n">rec_fib</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4.81 ms ± 625 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre></div></div> <p>Para calcular o vigésimo número ele demorou muito mais do que o algoritmo anterior, que calculou um número muito maior!! Por que será que isso aconteceu? Uma imagem pode ajudar a ilustrar o porquê disso.</p> <p><img src="../images/fibo.png" alt="Fib" /></p> <p>O que acontece é que a função recursiva acaba requisitando os mesmos números de fibonacci múltiplas vezes e, para números muito grandes, esse excesso de chamadas desnecessárias prejudica muito a perfomance do algoritmo. Muito mesmo, se você chamar a função com 60 como argumento, talvez não tenha paciência para esperar ela terminar de calcular.</p> <p>Existe um jeito bem simples de resolver esse problema, que vem da assim chamada programação dinâmica, um conjunto de técnicas para otimização de algoritmos. A técnica que cabe usar aqui é chamada de memoization, e consiste em “reciclar” os valores que já calculamos previamente, para não precisar recalculá-los. Isso é exatamente o que precisamos!</p> <p>Agora, como poderíamos fazer isso? Um jeito bem eficiente é usar um hash table, o que no Python é um set ou um dictionary. A vantagem dessa estrutura de dados é que o tempo de procura independe de quantos dados armazenados você tem ali:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ffib</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">memo</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">}):</span>
    <span class="k">try</span><span class="p">:</span> <span class="c1"># tente retornar um valor no 'memorizador'
</span>        <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

    <span class="k">except</span><span class="p">:</span> <span class="c1"># se não conseguir, calcule o numero
</span>        <span class="n">fib</span> <span class="o">=</span> <span class="n">ffib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">ffib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">fib</span> <span class="c1"># guarde-o
</span>        <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">timeit</span> <span class="n">ffib</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>178 ns ± 0.385 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">timeit</span> <span class="n">ffib</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>183 ns ± 8.12 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
</code></pre></div></div> <p>O que é muito mais rápido. É bem impressionante o quanto essa técnica pôde melhorar o código. Uma coisa a se notar, no entanto, é que se você chamar a função com 10000, pelo menos com esse código, dá “stack overflow”… o que eu não esperava e honestamente nem sei por que é assim.</p> <h5 id="por-álgebra-linear">Por Álgebra Linear</h5> <iframe width="560" height="315" src="https://youtube.com/embed/13r9QY6cmjc?t=2074" frameborder="0" allowfullscreen=""></iframe> <p>Finalmente, matrizes. Comecemos primeiro com a equação básica, $F_n = F_{n-1} + F_{n-2}$.</p> <p>Mas, para termos um sistema de equações lineares, precisamos de mais uma equação pelo menos. A escolha mais simples é: $F_{n-1} = F_{n-1} + 0\cdot F_{n-2}$. O que, em linguagem de matrizes, pode ser escrito como:</p> <p class="center">$\begin{bmatrix}F_{n} \\ F_{n-1}\end{bmatrix} = \begin{bmatrix}1 &amp; 1\\1 &amp; 0\end{bmatrix} \cdot \begin{bmatrix}F_{n-1} \\ F_{n-2}\end{bmatrix}$</p> <p>Uma denominação mais interessante para essa relação é: $ u_{t+1} = Au_t $. O papel que desempenha a matriz A é o de transformar o vetor no “tempo” t para nos dar o vetor no “tempo” seguinte. Estamos lidando aqui com um sistema dinâmico, que evolui no tempo, e queremos saber, por exemplo, qual o $u_{10000}$. Como podemos fazer isso?</p> <p>Bom, para começar, é conveniente considerarmos um vetor base $u_0$, que no nosso caso pode ser perfeitamente $\begin{bmatrix} 1 \\ 0 \end{bmatrix}$. Assim, segue diretamente que $u_1 = Au_0$. E, disso, que $u_2 = Au_1 = A \cdot A \cdot u_0 = A^2u_0$. Logo, a fórmula geral é: <script type="math/tex">u^k = A^ku_0</script>.</p> <p>O que sugere de imediato que a resposta reside nas potências da matriz. Mas isso pode ser bem pesado matematicamente. Felizmente, existe uma maneira muito conveniente para resolver esses casos, e envolve os autovalores/autovetores (<em>eigenvalues/eigenvectors</em>) de uma matriz. Mas, afinal, o que são eles?</p> <p><img src="../images/evectors.gif" alt="Eigenvectors" /></p> <p>Simply put, os autovetores são vetores característicos de uma matriz que, após transformados por ela, não mudam de direção, mas é possível que mudem em magnitude dependendo do autovalor. Matematicamente, <script type="math/tex">Ax = \lambda x</script></p> <p>Em que $x$ é um autovetor da matriz $A$ e $\lambda$ um autovalor do autovetor. Note que, por isso, o autovetor pode encolher (se $0 &lt; \lambda &lt; 1$), ou aumentar (se $\lambda &gt; 1$), ou apontar para a direção oposta (se $\lambda &lt; 0$) quando transformado.</p> <p>Agora, o próximo passo, um grande passo, é notar que nós podemos decompor a matriz $A$ em seus autovetores e autovalores. Isto é possível se os autovetores forem todos linearmente independentes, caso em que uma matriz cheia de autovetores tem uma inversa, e isso será crucial para nós.</p> <p>Daí que, tratando $S$ como uma matriz de autovetores nas colunas e $\Lambda$ como uma matriz de autovalores na diagonal e zeros em todo o resto, podemos afirmar que <script type="math/tex">AS = S\Lambda</script></p> <p>O que não é óbvio, mas que pode ser visto deste modo:</p> <p class="center">$A \cdot \begin{bmatrix}x_1 &amp; x_2 \\ x_1 &amp; x_2\end{bmatrix} = \begin{bmatrix}\lambda_{1} x_1 &amp; \lambda_{2} x_2 \\ \lambda_{1} x_1 &amp; \lambda_{2} x_2\end{bmatrix} = \begin{bmatrix}x_1 &amp; x_2 \\ x_1 &amp; x_2\end{bmatrix} \cdot \begin{bmatrix} \lambda_{1} &amp; 0 \\ 0 &amp; \lambda_{2}\end{bmatrix}$</p> <p>Caso não tenha ficado claro: cada coluna de $S$ é um autovetor. Quando fazemos $AS$, obtemos uma matriz cujas colunas são os autovetores vezes seus respectivos autovalores (consequência direta de $Ax = \lambda x$). Essa matriz pode, enfim, ser “diagonalizada” separando esses seus dois componentes como mostrado.</p> <p>Ok, mas por que isso é útil? Queremos investigar as potências de uma matriz afinal! Essa decomposição de matriz serve justamente a esse propósito. Vejamos.</p> <p>Vamos multiplicar $AS$ pela direita por $S^{-1}$. Isso dá: $A = S\Lambda S^{-1}$, já que $SS^{-1} = I$. Agora, $A^2 = S\Lambda S^{-1}S\Lambda S^{-1} = S \Lambda^{2}S^{-1}$. E, em geral:</p> <script type="math/tex; mode=display">A^k = S \Lambda^{k}S^{-1}</script> <p>E assim vemos o quanto a decomposição pode simplificar a exponenciação de uma matriz! Agora, retomando lá do início, $u_k = A^ku_0$ pode ser reescrito como $u_k = S \Lambda^{k}S^{-1}u_0$.</p> <p>Mas perceba que seria mais interessante termos $u_0$ em uma nova “forma”, mais especificamente, como uma combinação linear dos autovetores, $Sc = u_0$, onde c é o vetor de coeficientes que resolve esse sistema de equações, $c = S^{-1}u_0$. E, com isso, nós temos tudo que precisamos porque</p> <script type="math/tex; mode=display">u_k = A^ku_0 = S \Lambda^{k}S^{-1} Sc = S \Lambda^{k}c</script> <p>Isso implica que, no nosso caso, para uma matrix 2x2 (só dois autovetores), $u_k = c_1\lambda_{1}^{k}x_1 + c_2\lambda_{2}^{k}x_2$, onde os $x_i$ são os autovetores, e o restante escalares. O que indica que a evolução do nosso sistema de equações é totalmente ditada pelos autovalores (não importa quantas vezes a matriz A transforme os autovetores, a direção deles nunca muda).</p> <p>Agora resta calcular tudo com o NumPy.</p> <p>O primeiro passo é criar a matriz A. Logo depois, obter os autovalores/autovetores, nessa ordem, com a função <em>numpy.linalg.eig()</em>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="n">evalues</span><span class="p">,</span> <span class="n">evectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">evalues</span><span class="p">,</span> <span class="n">evectors</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s">'</span><span class="se">\n\n</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ 1.61803399 -0.61803399]

[[ 0.85065081 -0.52573111]
 [ 0.52573111  0.85065081]]
</code></pre></div></div> <p>Mas, lembrando que queremos os autovalores na matriz diagonal $\Lambda$. Também precisamos calcular o vetor c.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Lambda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">evalues</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">evectors</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
</code></pre></div></div> <p>Antes, vamos olhar para a nossa matriz $\Lambda$, porque ela pode revelar coisas interessantes:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Lambda</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([[ 1.61803399,  0.        ],
       [ 0.        , -0.61803399]])
</code></pre></div></div> <p>O primeiro número pode parecer familiar para o leitor, afinal é um dos mais famosos: o número de ouro. E é precisamente ele que descreve como os números de Fibonacci estão crescendo!! Como sabemos que $u_k = c_1\lambda_{1}^{k}x_1 + c_2\lambda_{2}^{k}x_2$, substituindo temos:</p> <script type="math/tex; mode=display">u_k = c_1\cdot(1.618)^{k}\cdot x_1 + c_2\cdot(-0.618)^{k}\cdot x_2</script> <p>E fica evidente que, para um k muito grande, o número de ouro é o que governa o crescimento dos números, com o outro termo tentendo a 0 com k aumentando arbitrariamente. Fica claro também que esses números crescem exponencialmente.</p> <p>Agora, vamos criar uma função para calcular $u_k$. Nela usaremos a matriz $S$ (evectors), o vetor c e a matriz $\Lambda$.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">FIB</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">evectors</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">Lambda</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">@</span> <span class="n">c</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">FIB</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">end</span> <span class="o">=</span> <span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1.]    [2.]    [3.]    [5.]    [8.]    [13.]   [21.]   [34.]   [55.]   [89.]   [144.]  [233.]  [377.]  [610.]
</code></pre></div></div> <p>Tudo o que fiz foi calcular $u_k$ com a fórmula e extrair do vetor resultante a primeira linha ($F_k$).</p> <p>E quanto à sua eficiência?</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">timeit</span> <span class="n">FIB</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
</code></pre></div></div> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>32.8 µs ± 1.46 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
</code></pre></div></div> <p>Não surpreende ser tão rápido, estamos usando o NumPy afinal.</p> <p>Mas a beleza dessa abordagem está menos em sua eficiência e mais no que a álgebra linear pode nos revelar. A partir dela pudemos entender muito melhor sobre esses números, o que governa o seu crescimento. Mas, além disso, problemas com sistemas dinâmicos como esse estão em todos os lugares, e lidar com eles requer inevitavelmente conhecer os autovetores/autovalores de uma matriz e como podemos usá-los.</p> <p>A sequência de Fibonacci é um bom exemplo para introduzir esses conceitos da álgebra linear, cujo conhecimento é exigido por muitos outros problemas mais práticos/complexos, como Cadeias de Markov, e o leitor pode achar interessante também que o algoritmo do Google tem como fundamento os autovetores de uma matriz de Markov. Enfim, trata-se de um tópico fascinante por si só.</p> <p>Antes de terminar o post, fica a minha recomendação para um melhor entendimento de tudo isso: a série de vídeos <a href="https://www.youtube.com/watch?v=fNk_zzaMoSs&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">“Essence of Linear Algebra”</a> do 3Blue1Brown e este <a href="http://setosa.io/ev/eigenvectors-and-eigenvalues/">site</a> que conta com ótimas visualizações do que acabamos de fazer aqui.</p> </article> <div class="page-navigation code"> <a class="next" href="https://phelipetls.github.io/metodo-de-newton" title="NEXT: Método de Newton">&lt;&lt;</a> <span> &middot; </span> <a class="home" href="https://phelipetls.github.io/" title="Back to Index">Index</a> <span> &middot; </span> <a class="prev" href="https://phelipetls.github.io/puzzle-do-cavalo-no-tabuleiro-infinito-com-numpy" title="PREV: Puzzle do cavalo no tabuleiro infinito com NumPy">&gt;&gt;</a> </div> <div class="center"> <b></b> <style> #share-buttons {display: inline-block; vertical-align: middle; } #share-buttons:after {content: ""; display: block; clear: both;} #share-buttons > div { position: relative; text-align: left; height: 36px; width: 32px; float: left; text-align: center; } #share-buttons > div > svg {height: 16px; fill: #d5d5d5; margin-top: 10px;} #share-buttons > div:hover {cursor: pointer;} #share-buttons > div.facebook:hover > svg {fill: #3B5998;} #share-buttons > div.twitter:hover > svg {fill: #55ACEE;} #share-buttons > div.linkedin:hover > svg {fill: #0077b5;} #share-buttons > div.pinterest:hover > svg {fill: #CB2027;} #share-buttons > div.gplus:hover > svg {fill: #dd4b39;} #share-buttons > div.mail:hover > svg {fill: #7D7D7D;} #share-buttons > div.instagram:hover > svg {fill: #C73B92;} #share-buttons > div.facebook > svg {height: 18px; margin-top: 9px;} #share-buttons > div.twitter > svg {height: 20px; margin-top: 8px;} #share-buttons > div.linkedin > svg {height: 19px; margin-top: 7px;} #share-buttons > div.pinterest > svg {height: 20px; margin-top: 9px;} #share-buttons > div.gplus > svg {height: 17px; margin-top: 9px; position: relative; left: 1px;} #share-buttons > div.mail > svg {height: 14px; margin-top: 11px;} </style> <span style="color: silver;"><br></br>Compartilhe: </span><div id="share-buttons"> <div class="facebook" title="Share this on Facebook" onclick="window.open('http://www.facebook.com/share.php?u=https://phelipetls.github.io/tres-algoritmos-para-a-sequencia-de-fibonacci');"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759h-306v-759h-255v-296h255v-218q0-186 104-288.5t277-102.5q147 0 228 12z"/></svg></div> <div class="twitter" title="Share this on Twitter" onclick="window.open('http://twitter.com/home?status=https://phelipetls.github.io/tres-algoritmos-para-a-sequencia-de-fibonacci');"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5t-115.5 248.5-184.5 210.5-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5t-114-159.5q33 5 61 5 43 0 85-11-112-23-185.5-111.5t-73.5-205.5v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5t371.5 99.5q-8-38-8-74 0-134 94.5-228.5t228.5-94.5q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z"/></svg></div> <div class="linkedin" title="Share this on Linkedin" onclick="window.open('https://www.linkedin.com/shareArticle?mini=true&url=https://phelipetls.github.io/tres-algoritmos-para-a-sequencia-de-fibonacci&title=&summary=&source=');"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M477 625v991h-330v-991h330zm21-306q1 73-50.5 122t-135.5 49h-2q-82 0-132-49t-50-122q0-74 51.5-122.5t134.5-48.5 133 48.5 51 122.5zm1166 729v568h-329v-530q0-105-40.5-164.5t-126.5-59.5q-63 0-105.5 34.5t-63.5 85.5q-11 30-11 81v553h-329q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5 114.5-15.5q171 0 275 113.5t104 332.5z"/></svg></div> <div class="gplus" title="Share this on Google Plus" onclick="window.open('https://plus.google.com/share?url=https://phelipetls.github.io/tres-algoritmos-para-a-sequencia-de-fibonacci');"><svg viewBox="0 0 2304 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1437 913q0 208-87 370.5t-248 254-369 91.5q-149 0-285-58t-234-156-156-234-58-285 58-285 156-234 234-156 285-58q286 0 491 192l-199 191q-117-113-292-113-123 0-227.5 62t-165.5 168.5-61 232.5 61 232.5 165.5 168.5 227.5 62q83 0 152.5-23t114.5-57.5 78.5-78.5 49-83 21.5-74h-416v-252h692q12 63 12 122zm867-122v210h-209v209h-210v-209h-209v-210h209v-209h210v209h209z"/></svg></div> <div class="mail" title="Share this through Email" onclick="window.open('mailto:?&body=https://phelipetls.github.io/tres-algoritmos-para-a-sequencia-de-fibonacci');"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1792 710v794q0 66-47 113t-113 47h-1472q-66 0-113-47t-47-113v-794q44 49 101 87 362 246 497 345 57 42 92.5 65.5t94.5 48 110 24.5h2q51 0 110-24.5t94.5-48 92.5-65.5q170-123 498-345 57-39 100-87zm0-294q0 79-49 151t-122 123q-376 261-468 325-10 7-42.5 30.5t-54 38-52 32.5-57.5 27-50 9h-2q-23 0-50-9t-57.5-27-52-32.5-54-38-42.5-30.5q-91-64-262-182.5t-205-142.5q-62-42-117-115.5t-55-136.5q0-78 41.5-130t118.5-52h1472q65 0 112.5 47t47.5 113z"/></svg></div> </div> </div> <div class="disqus_layout"> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://phelipetls.github.io/tres-algoritmos-para-a-sequencia-de-fibonacci'; this.page.identifier = '/tres-algoritmos-para-a-sequencia-de-fibonacci'; }; (function() { var d = document, s = d.createElement('script'); s.src = '//phelipetls-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript> </div> </div> <div class="footer"> <a href="https://github.com/phelipetls"><i class="fa fa-github"></i></a> <a style="padding-left:10px;", href="https://linkedin.com/in/phelipeteles"><i class="fa fa-linkedin"></i></a> <a style="padding-left:10px;", href="mailto:phelipe_teles@hotmail.com"><i class="fa fa-envelope"></i></a> <p> <span class="block">&copy; 2019 Phelipe Teles</span> <span class="block"><small>&lt;/&gt; Powered by <a href="https://jekyllrb.com/">Jekyll</a> and <a href="https://github.com/heiswayi/the-plain">The Plain theme</a>.</small></span> </p> </div> </body> </html>
